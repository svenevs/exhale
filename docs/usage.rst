Usage
========================================================================================

Using exhale can be simple or involved, depending on how much you want to change and
how familiar you are with things like Sphinx, Breathe, Doxygen, etc.  At the top level,
what you need is:

1. Your C++ code you want to document, with "proper" Doxygen documentation.  Please
   read the :ref:`doxygen_documentaion_specifics` for common documentation pitfalls,
   as well as features previously unavailable in standard Doxygen.
2. A sphinx documentation project ready to go.  See the
   `First Steps With Sphinx <http://www.sphinx-doc.org/en/stable/tutorial.html>`_
   tutorial for getting that off the ground.

.. contents:: Contents
   :local:
   :backlinks: none

.. _usage_quickstart_guide:

.. include:: ../README.rst
   :start-after: begin_quickstart_guide
   :end-before:  end_quickstart_guide

.. _usage_advanced_usage:

Additional Usage and Customization
----------------------------------------------------------------------------------------

Controlling the Layout of the Generated Root Library Document
****************************************************************************************

.. include:: reference/configs.rst
   :start-after: begin_root_api_document_layout
   :end-before:  end_root_api_document_layout

.. _usage_creating_the_treeview:

Clickable Hierarchies
****************************************************************************************

.. include:: reference/configs.rst
   :start-after: begin_clickable_hierarchies
   :end-before:  end_clickable_hierarchies

.. _usage_external_linkage:

Linking to a Generated File
****************************************************************************************

.. tip::

   This section describes writing links on the reStructuredText side of your
   documentation, e.g. inside of the value you provided in
   :data:`~exhale.configs.afterTitleDescription` or on your ``index.rst`` or something.

   In the actual code documentation, Breathe is typically able to infer links
   automatically (which is really great!), as well as you can also use ``\ref`` from
   Doxygen if that is not working.  See the :ref:`doxygen_documentaion_specifics`
   section for in-code documentation linkage.

   You can use the linking strategies in this section, but they are not nearly as
   convenient.

Assuming you have set ``primary_domain = 'cpp'`` (as shown in the
:ref:`usage_quickstart_guide`), you have two ways to link to documentation being
generated by Exhale.  You may want to do this to call attention to key classes or
functions that users should be aware of.

**Suggested Linking Strategy**
    By specifying the ``primary_domain``, you should be able to use the linking
    strategies `provided by Sphinx itself`__ *without* needing to prefix everything with
    ``cpp:``.  Some examples:

    +--------------------------------+-------------------------------------------------+
    | Action                         | Syntax                                          |
    +================================+=================================================+
    | Linking to a class             | ``:class:`namespace::ClassName```               |
    +--------------------------------+-------------------------------------------------+
    | Linking to a method of a class | ``:function:`namespace::ClassName::methodName```|
    +--------------------------------+-------------------------------------------------+
    | Linking to a function          | ``:function:`void namespace::funcName```        |
    +--------------------------------+-------------------------------------------------+

    __ http://www.sphinx-doc.org/en/stable/domains.html#id2

**Using Exhale's Internal Links**
    If the above are not working, you can try using the links that Exhale generates to
    perform its own internal linkage.  These links are much harder to use directly.

    .. tip::

       You would use these links if you need to link to something that the Sphinx domain
       does not have available, e.g. a File page being generated.

    As the generation of these links becomes a little entrenched (it takes place in the
    function :func:`~exhale.graph.ExhaleRoot.initializeNodeFilenameAndLink`) I advise you
    to simply generate the API once with ``make html``, and look at the **top** of the
    reStructuredText document.  For example, if you wanted to link to the file
    ``directory/common.hpp``, the link at the top of the file will usually be

    .. code-block:: rst

       .. _file_directory_common.hpp:

    Meaning in your reStructuredText you would write
    ``:ref:`file_directory_common.hpp```.

.. _usage_external_linkage_templates:

Linking to a Generated Template
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

.. tip::

   See the three ``DerivedClass`` examples on the `ExhaleCompanion File Page <ecfp_>`_
   that defines these examples.

   .. _ecfp: http://my-favorite-documentation-test.readthedocs.io/en/latest/api/file_arbitrary_DerivedClass.h.html#classes

.. note::

   **All** templates produce build warnings, but should still give "usable" output.
   See the FAQ entry on :ref:`faq_metaprogramming_and_template_specialization`

The links generated for templates are particularly obtuse.  Consider the following
definitions (implementation redacted):

.. code-block:: cpp

   namespace arbitrary {
       // the unspecialized template class
       template <typename T, unsigned int N>
       DerivedClass : BaseClass { /* ... */ };

       // a partial specialization; `struct arbitrary_struct` defined elsewhere
       template <unsigned int N>
       class DerivedClass<arbitrary_struct, N> : BaseClass { /* ... */ };

       // a full specialization
       template <>
       class DerivedClass<bool, 2> : arbitrary::BaseClass { /* ... */ };
   }

Keeping in mind that template classes with the same name but different template
parameters are not allowed, e.g.:

.. code-block:: cpp

   // definition 1
   template <typename T, unsigned int N>
   DerivedClass : arbitrary::BaseClass { /* ... */ };

   // definition 2
   template <bool useFloat, unsigned int N>
   DerivedClass : arbitrary::BaseClass { /* ... */ };

The challenge really amounts to how Doxygen is presenting this information, and the fact
that the filenames / reStructuredText links need to be "HTML Safe" (no ``<``, ``>``, or
``,``).

**Unspecialized Templates**
    The ``node.name`` has no templates, and the Doxygen XML provides a
    ``templateparamlist`` which is parsed into ``node.template_params``.

    **Filename**
        ``class_arbitrary__DerivedClass.rst``

    **reStructuredText Label**
        ``.. _template_class_arbitrary__DerivedClass:``.

**Partial Specializations**
    The ``node.name`` **has** templates, and the remaining unspecialized template
    parameters are parsed from the XML into ``node.template_params``.

    **Filename**
        ``class_arbitrary__DerivedClassLT__arbitrary__arbitrary_struct_COMMA_N__GT.rst``

    **reStructuredText Label**
        ``.. _template_class_arbitrary__DerivedClassLT__arbitrary__arbitrary_struct_COMMA_N__GT:``

**Full Specializations**
    The ``node.name`` **has** templates, but there is nothing to put into
    ``node.template_params``.

    **Filename**
        ``class_arbitrary__DerivedClassLT__bool_COMMA_2__GT.rst``

    **reStructuredText Label**
        ``.. _template_class_arbitrary__DerivedClassLT__bool_COMMA_2__GT:``

.. _usage_customizing_file_pages:

Page Level Customization
****************************************************************************************

.. include:: reference/configs.rst
   :start-after: begin_page_level_customization
   :end-before:  end_page_level_customization


.. _using_contents_directives:

Using Contents Directives
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

.. include:: reference/configs.rst
   :start-after: begin_page_level_customization_contents_directives
   :end-before:  end_page_level_customization_contents_directives

.. _usage_customizing_breathe_output:

Customizing Breathe Output
****************************************************************************************

.. include:: reference/configs.rst
   :start-after: begin_customizing_breathe_output
   :end-before:  end_customizing_breathe_output

.. _usage_fully_automated:

Fully Automated Building
----------------------------------------------------------------------------------------

It is preferable to have everything generated at once, e.g. if you wish to host your
documentation on Read the Docs.  Exhale is configured to enable this directly for you,
provided that you have the associated configuration variables setup.

.. _usage_exhale_executes_doxygen:

Using Exhale to Execute Doxygen
****************************************************************************************

.. include:: reference/configs.rst
   :start-after: begin_doxygen_execution_and_customization
   :end-before:  end_doxygen_execution_and_customization

Executing Doxygen Independently
****************************************************************************************

This is another option, just make sure that Doxygen is run **before** Exhale is.  See
the note at the bottom of the :ref:`usage_quickstart_guide`.

.. _doxygen_documentaion_specifics:

Doxygen Documentation Specifics
----------------------------------------------------------------------------------------

.. include:: reference/configs.rst
   :start-after: begin_doxygen_execution_and_customization
   :end-before:  end_doxygen_execution_and_customization

.. _file_and_namespace_level_documentation_in_exhale:

File and Namespace Level Documentation in Exhale
****************************************************************************************

Since the Breathe file / namespace directives cannot be used, Exhale implements a
"best-faith-effort" documentation parser.  It includes support for a few basic
block-level elements such as listings, but it is definitively not robust.  If the file
or namespace level documentation is rendering in unexpected ways, this is because your
documentation is "too advanced" for Exhale's mini-parser.

.. tip::

   See the :func:`~exhale.parse.walk` method for the currently supported Doxygen
   formatting being parsed.

However, the solution is easy: use a verbatim reStructuredText environment in the
documentation.  See how to do that in the :ref:`Doxygen ALIASES <doxygen_aliases>`
section.

.. note::

   By entering a verbatim RST environment, doxygen commands such as ``\ref`` are **no
   longer available**.  Or rather, they will be parsed as-is without actually generating
   a link to the desired target.  Since you've now entered a verbatim RST environment,
   you would instead use the Sphinx domain links.

   So if you were linking to ``class namespace::ClassName`` using
   ``\ref namespace::ClassName``, this would now change to be
   ``:class:`namespace::ClassName```.  See the `Sphinx Cross Referencing Guide <cross_>`_
   for some more examples.  There is also an `Intersphinx Guide <intersphinx_>`_
   available on the companion website with some examples of linking to macros.

.. _cross: http://www.sphinx-doc.org/en/stable/domains.html#cross-referencing-syntax

.. _intersphinx: http://my-favorite-documentation-test.readthedocs.io/en/latest/using_intersphinx.html


Start to finish for Read the Docs
----------------------------------------------------------------------------------------

Assuming you already had the code that you are generating the API for documented,
navigate to the top-level folder of your repository.  Read the Docs (RTD) will be
looking for a folder named either ``doc`` or ``docs`` at the root of your repository
by default::

    $ cd ~/my_repo/
    $ mkdir docs

Now we are ready to begin.

1. Generate your sphinx code by using the ``sphinx-quickstart`` utility.  It may look
   something like the following:

   .. code-block:: console

      $ ~/my_repo/docs> sphinx-quickstart
      Welcome to the Sphinx 1.6.3 quickstart utility.

      Please enter values for the following settings (just press Enter to
      accept a default value, if one is given in brackets).

      Enter the root path for documentation.
      > Root path for the documentation [.]:

      You have two options for placing the build directory for Sphinx output.
      Either, you use a directory "_build" within the root path, or you separate
      "source" and "build" directories within the root path.
      > Separate source and build directories (y/n) [n]:

      Inside the root directory, two more directories will be created; "_templates"
      for custom HTML templates and "_static" for custom stylesheets and other static
      files. You can enter another prefix (such as ".") to replace the underscore.
      > Name prefix for templates and static dir [_]:

      ... and a whole lot more ...

2. This will create the files ``conf.py``, ``index.rst``, ``Makefile``, and ``make.bat``
   if you are supporting Windows.  It will also create the directories ``_static`` and
   ``_templates`` for customizing the sphinx output.

3. Create a ``requirements.txt`` file with the line ``exhale`` so RTD will install it:

   .. code-block:: bash

      $ ~/my_repo/docs> echo 'exhale' > requirements.txt

4. Follow the :ref:`usage_quickstart_guide`.

5. Edit ``conf.py`` to use the RTD Theme or whichever theme you like.  From the RTD
   Theme README, you would do

   .. code-block:: py

      # on_rtd is whether we are on readthedocs.org, this line of code grabbed from docs.readthedocs.org
      on_rtd = os.environ.get('READTHEDOCS', None) == 'True'

      if not on_rtd:  # only import and set the theme if we're building docs locally
          import sphinx_rtd_theme
          html_theme = 'sphinx_rtd_theme'
          html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]

6. Go to the admin page of your RTD website and select the *Advanced Settings* tab.
   Make sure the *Install your project inside a virtualenv using* ``setup.py install``
   button is checked.  In the *Requirements file* box below, enter
   ``docs/requirements.txt`` assuming you followed the steps above.

   I personally prefer to keep the ``requirements.txt`` hidden in the ``docs`` folder
   so that it is implicit that those are only requirements for building the docs, and
   not the actual project itself.

And you are done.  Make sure you ``git add`` all of the files in your new ``docs``
directory, RTD will clone your repository / update when you push commits.  You can
build it locally using ``make html`` in the current directory, but make sure you do not
add the ``_build`` directory to your git repository.

.. tip::

   While you are at it, you should probably add to your ``.gitignore``:

   .. code-block:: bash

      docs/_build
      # wherever you told breathe_projects to look
      docs/doxyoutput
      # wherever you told Exhale containmentFolder is
      docs/api

I hope that the above is successful for you, it looks like a lot but it's not too bad...
right?
